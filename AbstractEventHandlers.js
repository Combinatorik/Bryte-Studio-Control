'use strict';	

/**
* This is an abstract object.  It takes in an object and handles registering/unregistering event listeners to it and the document for smooth moving.
*/
class AbstractMovableObjectEventHandler
{
	//DOM object references.
	movable;
	
	//Control variables.
	faderMouseDown = 0;
	mouseDownX=0;
	mouseDownY=0;
	
	/**
	* The constructor takes in a reference to the DOM object that is movable.  It then attaches mouse down/up event listeners to it and automatically handles registering/unregisterting mouse move events on mouse down/up.
	* @param {Object} control is a reference to the movable DOM object.
	*/
	constructor(control)
	{
		if (this.constructor === AbstractMovableObjectEventHandler)
			throw "Unable to construct abstract class";
		
		if (control == null)
			throw "Invalid track component DOM object reference";
		
		this.movable = control;
		this.movable.addEventListener("mousedown", this);
		this.movable.addEventListener("touchstart", this);
	}
	
	/**
	* Abstract method.  This method is what implements behavior when the object is clicked on and the mouse is moved.  It needs to be overriden to provide behaivor.
	* @param {Event} event is the event object generated by the system.
	*/
	mouseMoveHandler(event) 
	{
		throw "Abstract mouseMoveHandler function called";
	}
	
	/**
	* Abstract method.  This method is called whenever the movable object is clicked on for additional setup.  Overriding this method is optional.
	* @param {Event} e is the event object generated by the system.
	*/
	mouseDownInit(e){}
	
	/**
	* Abstract method.  This method is called whenever the movable object is unclicked on for additional cleanup.  Overriding this method is optional.
	* @param {Event} e is the event object generated by the system.
	*/
	cleanup(e){}
	
	/**
	* Getter.  Returns true if the mouse is currently down on the object and false if not.
	*/
	get mouseIsDown()
	{
		return this.faderMouseDown;
	}
	
	/**
	* Getter.  Returns the last x position in page coordinates that the mouse was when clicked on this object.
	*/
	get mouseDownX()
	{
		return this.mouseDownX;
	}
	
	/**
	* Getter.  Returns the last y position in page coordinates that the mouse was when clicked on this object.
	*/
	get mouseDownY()
	{
		return this.mouseDownY;
	}
	
	/*  Private Methods  */
	handleEvent(event)
	{
		if ((event.type == "mousemove" || event.type == "touchmove") && this.faderMouseDown)
			this.mouseMoveHandler(event);
		else if (event.type == "mousedown")
			this.mouseDownHandler(event);
		else if (event.type == "mouseup" || event.type == "touchend")
			this.mouseUpHandler(event);
		else if (event.type == "touchstart" && event.touches.length > 0 && !this.faderMouseDown) 
			this.mouseDownHandler(event);
	}
	
	mouseDownHandler(e)
	{	
		if (e.defaultPrevented)
			return;
		else
			e.preventDefault();
		
		//Attach mouse move and mouse up listeners to the entire page.
		document.addEventListener("mousemove", this, false);
		document.addEventListener("touchmove", this, false);
		document.addEventListener("mouseup", this, false);
		document.addEventListener("touchend", this, false);
		
		//Record mouse down position;
		this.mouseDownX = e.pageX;
		this.mouseDownY = e.pageY;
		
		//Engage control.
		this.faderMouseDown = 1;
		
		//User-define initialization
		this.mouseDownInit(e);
	}
	
	mouseUpHandler(e)
	{
		//Deattach listeners from the entire page.
		document.removeEventListener("mousemove", this, false);
		document.removeEventListener("touchmove", this, false);
		document.removeEventListener("mouseup", this, false);
		document.removeEventListener("touchend", this, false);
		
		//Disengage control.
		this.faderMouseDown = 0;
		
		//Call cleanup function for concrete objects to call if needbe.
		this.cleanup(e);
	}
};

/**
* The MultiClickHandler object handles clicking events and executes a specific function based on how many clicks have been done.
*/
class MultiClickHandler
{
	clickTimer=0;
	clicks=0;
	timer=0;
	functions;
	fnum;
	lastEvent;
	static timerTime=200;
	
	/**
	* @param {SVGElement} is the control to listen to.
	* @param {Object} is a key-value pair of number of clicks and function to execute.
	*/
	constructor(control, functions)
	{	
		this.functions = functions;
		control.addEventListener("mousedown", this);
		control.addEventListener("touchstart", this);
	}
	
	handleEvent(event)
	{
		//Increment clicks
		this.clicks++;
		this.fnum = this.clicks;
		this.lastEvent = event;
		
		//Reset timer
		if (this.timer)
			clearTimeout(this.timer);
		this.timer = setTimeout(() => {this.resetCount()}, MultiClickHandler.timerTime);
	
		if (this.clickTimer)
			clearTimeout(this.clickTimer);

		if (this.functions[this.fnum])
		{
			this.clickTimer = setTimeout(() => {this.functions[this.fnum](this.lastEvent)}, MultiClickHandler.timerTime);
		}
	}
	
	resetCount()
	{
		this.clicks=0;
		this.timer=0;
		this.clickTimer=0;
	}
};